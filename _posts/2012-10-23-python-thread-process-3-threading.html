---
layout: default
title: Python线程与进程3-threading
author: zzh
thisdate: 2012-10-23
classification: script
---
<p id="fortitle"> {{ page.thisdate }} </p>

<pre class="preclass">
    由于要做把一个多线程改成多进程，看一下相关方面的东西，总结一下，主要是以下几个相关的标准库
    1：subprocess
    2：signal
    3：threading
    4：multiprocessing
    这个是第三个 threading
    下面的代码我只在基于ubuntu的deepin12.06(Linux zzh 3.2.0-32-generic #51-Ubuntu SMP Wed Sep 26 21:32:50 UTC 2012 i686 athlon i386 GNU/Linux)上测试过
</pre>
<h2>threading</h2>
<h3>threading-Thread</h3>
<pre class="codepre"><code>
#logging是线程安全的
import logging
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='[%(levelname)s] (%(threadName)-10s) %(message)s',
    )

def worker():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

def my_service():
    logging.debug('Starting')
    time.sleep(3)
    logging.debug('Exiting')

t = threading.Thread(name='my_service', target=my_service)
w = threading.Thread(name='worker', target=worker)
w2 = threading.Thread(target=worker) # use default name

w.start()
w2.start()
t.start()
</code></pre>
<h3>守护与非守护线程</h3>

<pre class="preclass">
守护线程就是不阻挡主程序退出，自己干自己的
threadname.setDaemon(True)
就这句
等待守护线程退出，要加上join,join可以传入浮点数值，等待n久就不等了
</pre>
<pre class="codepre"><code>
import threading
import time
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='(%(threadName)-10s) %(message)s',
                    )

def daemon():
    logging.debug('Starting')
    time.sleep(2)
    logging.debug('Exiting')

d = threading.Thread(name='daemon', target=daemon)
d.setDaemon(True)

def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

d.join(1)
print 'd.isAlive()', d.isAlive()
t.join()
</code></pre>
